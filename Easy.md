# 简单题
 [toc]
* * *
## 1.两数之和
### 1.1题目描述
1

### 1.2解题思路
1

### 1.3代码
1

### 1.4总结
1
* * *
## 2.整数反转
### 2.1题目描述
1
### 2.2解题思路
1
### 2.3代码
1
### 2.4总结
1
* * *
## 3.回文数
### 3.1题目描述
1
### 3.2解题思路
1
### 3.3代码
1
### 3.4总结
1
* * *
## 4.罗马数字转整数
### 4.1题目描述
1

### 4.2解题思路
1

### 4.3代码
1

### 4.4总结
1
* * *
## 5.最长公共前缀
### 5.1题目描述
编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 ""。


示例1:
>输入：strs = ["flower","flow","flight"]
>输出："fl"


示例2：
>输入：strs = ["dog","racecar","car"]
>输出：""
>解释：输入不存在公共前缀。

### 5.2解题思路
解题思路如下：

其中 m 是字符串数组中的字符串的平均长度，n 是字符串的数量。

1. 纵向扫描：从下标0开始，判断每一个字符串的下标0，判断是否全部相同。直到遇到不
全部相同的下标。时间性能为O(n*m)。
2. 横向扫描：前两个字符串找公共子串，将其结果和第三个字符串找公共子串……直到最后一个串。时间性能为O(n*m)。
3. 借助trie字典树。将这些字符串存储到trie树中。那么trie树的第一个分叉口之前的单分支树的就是所求。
4. 利用数组排序特性，在排序好的数组中，提取第一个元素与最后一个元素，进行公共字符串的提取即为最短前缀字符串。

### 5.3代码
这里只对3、4两种方案进行解释

解法3：
```java
    public String longestCommonPrefix(String[] strs) {
        String ret ="";
        int i;
        Arrays.sort(strs);
        String s1 = strs[0];
        String s2 = strs[strs.length-1];
        for(i=0;i<s1.length();i++)
            if(s1.charAt(i)!=s2.charAt(i))
                break;
        ret = s1.substring(0,i);
        return ret;
    }
```
解法4：
```java

```

### 5.4总结
​	这道题目主要是用到了数组和字符串的一些函数，包括Arrays.sort()、substring字符串截取等；横向扫描与纵向扫描是差不多的，都是字符串之间相互比较，利用数组排序特征是两者的升级，利用trie字典树呢，暂时还没写，再议！
* * *
## 6.有效的括号
### 6.1题目描述
给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。

2. 左括号必须以正确的顺序闭合。

示例1：
>输入：s = "()"
>输出：true

示例2：
>输入：s = "()[]{}"
>输出：true

示例3：
>输入：s = "(]"
>输出：false

示例4：
>输入：s = "([)]"
>输出：false

示例5：
>输入：s = "{[]}"
>输出：true

### 6.2解题思路
首先要弄清楚，字符串里的括号不匹配有几种情况：

1. 第一种情况，字符串长度为奇数必然不匹配。
2. 第二种情况，整个字符串中没有一个连在一起匹配的括号。

接下来是两种解法：

​	第一种解法比较精巧，通过replaceAll函数，将所有的连在一起的()、[]、{}变为“”，因为每次匹配至少有一个连在一起的括号，因此只要匹配二分之一字符串长度次，就可以判断是否有效，但这种方法复杂度较高，不推荐。

第二种方法是利用栈的特殊性求解

​	我们遍历给定的字符串 s。当我们遇到一个左括号时，我们会期望在后续的遍历中，有一个相同类型的右括号将其闭合。由于后遇到的左括号要先闭合，因此我们可以将这个左括号放入栈顶。

​	当我们遇到一个右括号时，我们需要将一个相同类型的左括号闭合。此时，我们可以取出栈顶的左括号并判断它们是否是相同类型的括号。如果不是相同的类型，或者栈中并没有左括号，那么字符串 s 无效，返回 False。为了快速判断括号的类型，我们可以使用哈希表存储每一种括号。哈希表的键为右括号，值为相同类型的左括号。

​	在遍历结束后，如果栈中没有左括号，说明我们将字符串 ss 中的所有左括号闭合，返回 True，否则返回 False。

​	注意到有效字符串的长度一定为偶数，因此如果字符串的长度为奇数，我们可以直接返回 False，省去后续的遍历判断过程。


​	时间复杂度：O(n)，其中 n 是字符串 s 的长度。

​	空间复杂度：O(n + Σ )O(n+∣Σ∣)，其中 Σ 表示字符集，本题中字符串只包含  种括号，∣Σ∣=6。栈中的字符数量为 O(n)，而哈希表使用的空间为 O(∣Σ∣)，相加即可得到总空间复杂度。

### 6.3代码
第一种解法：

```java
    public boolean isValid(String s) {
        if(s.length()%2==0) {
            int length = s.length() / 2;
            for (int i = 0; i < length; i++) {
                String s1 = s;
                s = s.replace("()", "").replace("{}", "").replace("[]", "");
                if (s.length() == 0)
                    return true;
                else if (s1.equals(s))
                    break;
            }
        }
        return false;
    }
```

第二种解法：

```java
    public boolean isValid(String s) {
        if(s.length() %2 ==1)
            return false;
        HashMap<Character,Character> map = new HashMap<>();
        map.put('(',')');
        map.put('[',']');
        map.put('{','}');
        LinkedList<Character> stack = new LinkedList<>();
        for(Character c : s.toCharArray()){
            if(map.containsKey(c))
                stack.addLast(c);
            else if(stack.isEmpty()||map.get(stack.removeLast()) != c)
                return false;
        }
        return stack.isEmpty();
    }
```

### 6.4总结
栈：根据其特性适合用在匹配的问题上

​	题意其实就像我们在写代码的过程中，要求括号的顺序是一样的，有左括号，相应的位置必须要有右括号。

​	如果还记得编译原理的话，编译器在 词法分析的过程中处理括号、花括号等这个符号的逻辑，也是使用了栈这种数据结构。

​	再举个例子，linux系统中，cd这个进入目录的命令我们应该再熟悉不过了。
```
cd a/b/c/../../
```
​	这个命令最后进入a目录，系统是如何知道进入了a目录呢 ，这就是栈的应用。数据结构与算法的应用往往隐藏在我们看不到的地方！

* * *
